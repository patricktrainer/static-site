
    <!DOCTYPE html>
    <html>
        <head>
            <meta charset="utf-8">
            <meta name="viewport" content="width=device-width">
            <title>Hacking up your own shell completion Computing wit 8e8cd2c07ca44b0c8986a482e9f3c05b</title>
            
            
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/open-fonts@1.1.1/fonts/inter.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@exampledev/new.css@1.1.2/new.min.css">
    <link rel="stylesheet" href="https://unpkg.com/github-syntax-dark@latest/lib/github-dark.css"/>
    
        </head>
        <body>
            <header>
                <nav>
                    <a href="https://patricktrainer.github.io/static-site">Home</a> /
                    <a href="https://github.com/patricktrainer">GitHub</a> / 
                </nav>
            </header>
            <h1>Hacking up your own shell completion | Computing with Jeremy</h1>
<p>Created: Mar 6, 2020 8:31 PM
URL: https://feltrac.co/environment/2020/01/18/build-your-own-shell-completion.html</p>
<p>In this post I’ll be walking through a simple hack I added to my shell that I think makes me more productive (if nothing else it makes me happy).</p>
<p>Note that all this applies to most common shells, but my examples will be using <code>[fish](https://fishshell.com/)</code> since that’s what I’ve been using as of late.</p>
<p>I’ll also be talking about using <a href="https://github.com/junegunn/fzf">fzf</a> as a part of this hack. You can use <code>fzf</code> or not with this idea, but I like the feel of it :).</p>
<h2>Introducing: My Problems</h2>
<p>As a full-stack (frontend, backend, and firmware) software engineer, I use quite a few tools to build, test, run, version control, and style check the code I write.</p>
<p>At my company we built this pretty simplistic go program that is really a collection of scripts for building and testing out parts of our application.</p>
<p>We’ll call the tool <code>doer</code> for fun.</p>
<p>Those things can be listed using the command <code>doer -list</code>.</p>
<p>No one really bothered making autocompletion scripts for 3+ shells used across the company for an internal tool, but I was having trouble remembering the exact abbreviations involved in the command I wanted to run.</p>
<h2>Script It!</h2>
<p>Some people at my company use <code>fzf</code>. For the uninitiated, <code>fzf</code> is a program that lets you select from multiple options using a fuzzy find search.</p>
<p>The cool thing about <code>fzf</code> is that you can send it a newline separated list of items, and it’ll handle all the user interaction to select one and return the selected item.</p>
<p>Here’s an example of using <code>fzf</code> to choose a line from a file and echo it.</p>
<p>I’ve often used <code>fzf</code> as a file finder, you can simply run something like <code>git ls-files | fzf</code>, and pass the output to your editor, and you’ve already made a git aware fuzzy file finder, running this inside your editor like <a href="https://github.com/junegunn/fzf.vim">fzf-vim</a> makes this even more powerful.</p>
<p>One quick solution to our <code>doer</code> problem is to write a bash script like this:</p>
<p>```</p>
<h1>!/bin/bash</h1>
<p>doer $(doer -list | fzf)
```</p>
<p>Here we just use command substitution to run <code>doer</code>’s list command, pass it to <code>fzf</code>, then run doer with the result.</p>
<p>Here’s it in action:</p>
<p>This works <em>really</em> well, but unfortunately you lose shell history when you run this command.</p>
<p>For example, lets say I finally figure out through the fuzzy completion version of <code>doer</code> that I really want to run <code>doer gen/other_thing</code>, because it generates a file based on one I’m currently modifying.</p>
<p>So I run the command once, fuzzy selecting my option, modify some code, then return to my shell to quickly repeat the command I had just tried.</p>
<p>After a quick <code>CTRL-P</code> (or up arrow), or <code>CTRL-R</code>, I find that the only thing in my history is <code>doer-fuzzy</code>. That means I have to fuzzy find my option again and rerun, and it means I don’t have a great history of what I’ve run in the past. What a drag!</p>
<h2>Maintaining History</h2>
<p>My first thought here was to somehow append the underlying command being run by <code>doer-fuzzy</code> to my shell history, but I quickly found out that this is hard, hacky, and no one really does this.</p>
<p>So really what we want is to trigger argument completion in the shell, so that by the time I hit return to trigger the command, the full command I’m interested in is on the shell already.</p>
<p>Oh wait… that sounds like just normal shell completion, you the know, the tab-tab-tab-tab-tab approach.</p>
<p>Okay fine, I guess I can add proper shell completion to the command using <code>fish</code>’s built in <code>complete</code> command, add it to the repo, and set up an install script. But now that I think about it, I have several commands I use that don’t support completion (not just <code>doer</code>), or complete too much stuff for my 90% use case, or just support so many options its a bit painful to autocomplete through tab key wear out.</p>
<p>What if there was a way to strap an <code>fzf</code> completion thing into my shell, that I fully control through just a couple lines of <code>fish</code> script, that doesn’t interfere with built-in completion, and allows me to quickly add bindings to any command I frequently run?</p>
<h2>Introducing Personalized FZF Completion!</h2>
<p><code>fzf</code> already sort of does this type of thing when you install the <code>fzf</code> bindings to your shell. Regardless of your currently typed command, you can hit <code>CTRL-T</code> to search for a list of files in your current directory. For example, lets say we’re trying to open a file in <code>nvim</code>.</p>
<p>What if we could copy how <code>CTRL-T</code> works, but replace the hardcoded <code>fzf</code> command with a contextual one that we control?</p>
<p>Here’s a basic <code>fish</code> script to accomplish the core part of this. Basically we just match on any commands that are prefixed with <code>doer</code>, and return an appropriate autocompletion function for that command.</p>
<p><code>function get-completion-command
    set -l cmd (commandline)
    switch $cmd
        case 'doer *'
            echo 'doer -list'
        case '*'
            return 1
    end
end</code></p>
<p>This function gets called in a skeleton version of <code>fzf</code>’s <code>CTRL-T</code> command.</p>
<p>```
function fzf-smart-completion -d "List files and folders"
    set -l commandline (__fzf_parse_commandline)
    set -l dir $commandline[1]
    set -l fzf_query $commandline[2]</p>
<pre><code># use our cool new completion checker
set -l FZF_CMD (get-completion-command); or return

# fzf edge case and formatting (prevents fzf from taking up the whole screen)
set FZF_HEIGHT 40%
begin
  set -lx FZF_DEFAULT_OPTS "--height $FZF_HEIGHT --reverse $FZF_DEFAULT_OPTS $FZF_CMD[2]"
  eval "$FZF_CMD[1] | "(__fzfcmd)' -m --query "'$fzf_query'"' | while read -l r; set result $result $r; end
end
if [ -z "$result" ]
  commandline -f repaint
  return
else
  # Remove last token from commandline.
  commandline -t ""
end
for i in $result
  commandline -it -- (string escape $i)
  commandline -it -- ' '
end
commandline -f repaint
</code></pre>
<p>end</p>
<p>bind -M insert \et fzf-smart-completion
bind \et fzf-smart-completion
```</p>
<p>With this little bit of <code>fish</code> scripting, we now have a pretty cool <code>ALT-T</code> command that runs our own fuzzy autocomplete like so.</p>
<p>This got me thinking, what other commands could benefit from this type of completion?</p>
<p>One example is <code>go test</code>, which for my use cases, should only run on source controlled files ending in <code>_test.go</code>. There’s no reason to autocomplete every file in my repo, just the test ones is perfect!</p>
<p>The same idea applies to our frontend test runner, if I’m typing <code>yarn test</code>, I probably only want to see typescript files ending with our <code>.test</code> convention.</p>
<p><code>function get-completion-command
    set -l cmd (commandline)
    switch $cmd
        case 'doer *'
            echo 'doer -list'
        case 'go test *'
            echo 'git ls-files | grep _test.go'
        case 'yarn test *'
            echo 'git ls-files | grep .test.ts'
        case '*'
            return 1
    end
end</code></p>
<p>You can see the go tester in action here:</p>
<p>Another useful thing I’ve found is automating some routine <code>git</code> commands.</p>
<p>Obviously there exist quite a few <code>git</code> UIs that try to allow you to use <code>git</code> more quickly than the CLI interface, but I have always come back to the CLI because frankly (1) there’s more documentation, and (2) it doesn’t have performance issues on massive monorepos that I’ve seen in every <code>git</code> UI (cough cough <a href="https://magit.vc/manual/magit/Performance.html#Performance">magit</a>).</p>
<p>Good <code>git</code> autocomplete is awesome and likely used by everyone, but we can extend it using this same interface.</p>
<p>Simply adding the following gives you a <code>git add</code> command that completes only changed files and allows showing a toggleable preview of the file changes.</p>
<p><code>case 'git add *'
    echo 'git diff --name-only'
    echo '--bind='ctrl-space:toggle-preview' --preview 'git diff --color=always {}' -m'</code></p>
<p>If you look hard enough at these scripts, you’ll find there are flaws or gaps in this completion system.</p>
<p>A common example for me is my <code>git checkout</code> completion. I simply list local branches as targets. This obviously ignores a lot of different targets to the <code>git checkout</code> command including commits, specific files, remote branches, and tags, but for me, &gt; 90% of the time I’m using it to just switch branches.</p>
<p>On top of that, using this new framework doesn’t break or invalidate any other tool you have, I frequently fall back to <code>fish</code>’s <code>git</code> completion when I’m doing something more specific, but I’m happy that my most common access patterns are now a bit faster.</p>
<p>This pattern also doesn’t add a layer of abstraction over the CLI tools you use, your shell history still is useful, you use the same CLI tools as everyone else, you just hopefully save yourself a bit of typing.</p>
<p>I’m quite sure this sort of thing would be pretty trivial to get working in both <code>bash</code> and <code>zsh</code> since they support <code>fzf</code>’s <code>CTRL-T</code> command as well. If I get a lot of long term use out of this maybe I’ll try getting a similar idea running in a few shells and share those scripts.</p>
        </body>
    </html>
    