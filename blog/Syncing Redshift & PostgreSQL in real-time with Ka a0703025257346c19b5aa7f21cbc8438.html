
    <!DOCTYPE html>
    <html>
        <head>
            <meta charset="utf-8">
            <meta name="viewport" content="width=device-width">
            <title>Syncing Redshift & PostgreSQL in real-time with Ka a0703025257346c19b5aa7f21cbc8438</title>
            
            
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/open-fonts@1.1.1/fonts/inter.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@exampledev/new.css@1.1.2/new.min.css">
    <link rel="stylesheet" href="https://unpkg.com/github-syntax-dark@latest/lib/github-dark.css"/>
    
        </head>
        <body>
            <header>
                <nav>
                    <a href="https://patricktrainer.github.io/static-site">Home</a> /
                    <a href="https://github.com/patricktrainer">GitHub</a> / 
                </nav>
            </header>
            <h1>Syncing Redshift &amp; PostgreSQL in real-time with Kafka Connect</h1>
<p>Created: Feb 21, 2020 12:02 PM
URL: https://blog.insightdatascience.com/from-postgresql-to-redshift-with-kafka-connect-111c44954a6a</p>
<p><img alt="1*pYpurugpdz35peaoDNB93A.png" src="Syncing%20Redshift%20&amp;%20PostgreSQL%20in%20real-time%20with%20Ka%20a0703025257346c19b5aa7f21cbc8438/1pYpurugpdz35peaoDNB93A.png" /></p>
<p>I read about Kafka Connect a while back and always wanted to explore how it worked. It’s a very attractive feature because a significant part of processing data involves taking data from one system to the other. With Kafka becoming a convergence point for many organizations and being used as the backbone of data infrastructure at a lot of companies, Kafka Connect is a great abstraction to make integration with Kafka easy.</p>
<p>Before showing Kafka Connect, we’ll walk through some setup</p>
<ul>
<li>Setting up a distributed Kafka cluster</li>
<li>Setting up a PostgreSQL database on AWS RDS</li>
<li>Setting up an AWS Redshift instance</li>
<li>Setting up Confluent’s open source platform</li>
</ul>
<p>If you’re curious about how Kafka Connect works, I highly recommend reading the <a href="http://docs.confluent.io/3.1.2/connect/concepts.html">concepts</a> and <a href="http://docs.confluent.io/3.1.2/connect/design.html">architecture and internals</a> of Kafka Connect on Confluent’s platform documentation.</p>
<h2>Setting up a Kafka cluster</h2>
<p>As discussed in a <a href="https://blog.insightdatascience.com/ansible-playbooks-for-kafka-and-zookeeper-with-ec2-dynamic-inventory-8f317d4d2bfc">previous blog</a>, we’ll be using <a href="https://github.com/InsightDataScience/ansible-playbook">Ansible playbooks</a> to deploy a Kafka cluster on AWS. The yml file to launch EC2 instances is as follows:</p>
<p>We can launch these EC2 instances with the command</p>
<p><code>~$</code></p>
<p>Once the EC2 nodes are ready, we can deploy and start Kafka on these machines with the following two commands:</p>
<h2>Setting up a PostgreSQL instance on AWS RDS</h2>
<p>Follow the steps <a href="http://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_GettingStarted.CreatingConnecting.PostgreSQL.html#CHAP_GettingStarted.Creating.PostgreSQL">here</a> to launch a PostgreSQL instance on AWS RDS. Once the instance has been created, let’s access the database using <code>[psql](https://www.postgresql.org/docs/9.5/static/app-psql.html)</code> from one of the EC2 machines we just launched.</p>
<p>To setup psql, we need to SSH into one of the machines for which we need a public IP. We can get the public IPs of the running machines using the command or from the AWS console.</p>
<p><code>~$</code></p>
<p>Let’s SSH into the first machine.</p>
<p><code>~$</code></p>
<p>Once in the EC2 machine, let’s install postgesql-client.</p>
<p><code>~$~$</code></p>
<p>Now, let’s get the endpoint of the PostgreSQL instance from the RDS page and connect to it using <code>psql</code>.</p>
<p><code>~$ psql -h kafka-postgres.cvmmptcmh2sg.us-west-2.rds.amazonaws.com &lt;database&gt; &lt;username&gt;</code></p>
<p>Replace the endpoint with your RDS endpoint. You’ll be asked for the password — enter the password and you will be connected to the PostgreSQL database.</p>
<h2>Inserting data into PostgreSQL</h2>
<p>Let’s now create a <code>users</code> table in PostgreSQL using the following SQL statement:</p>
<p>Let’s insert a few rows in this table.</p>
<p>We can see the data in the table as below:</p>
<p>Now that we have some data in our PostgreSQL table, we can use Kafka Connect to get these rows as messages in a Kafka topic and have a process listening for any inserts/updates on this table.</p>
<h2>Setting up Confluent’s open source platform</h2>
<p>Kafka Connect uses the concept of connectors which define where the data should be copied to and from. We’ll be using the JDBC connectors provided in the <a href="https://www.confluent.io/product/confluent-platform/">Confluent’s open source platform</a>. For that, let’s download Confluent’s open source platform on one of the machines using the following script:</p>
<h2>Postgres source configuration</h2>
<p>Example configurations for source and sink JDBC connectors for SQLite are present in the directory <code>/usr/local/confluent/etc/kafka-connect-jdbc</code>. To ingest data from PostgreSQL we will use the template <code>source-quickstart-sqlite.properties</code>. Copy this file and name it <code>source-postgres.properties</code>.</p>
<p><code>~$ cp /usr/local/confluent/etc/kafka-connect-jdbc/source-quickstart-sqlite.properties /usr/local/confluent/etc/kafka-connect-jdbc/source-postgres.properties</code></p>
<p>We’ll change the following properties in this file:</p>
<ul>
<li><code>name</code>: name for the connector</li>
<li><code>connection.url</code>: JDBC endpoint for the PostgreSQL database</li>
<li><code>mode</code>: the JDBC source connector supports various modes, which you can read about <a href="http://docs.confluent.io/3.1.2/connect/connect-jdbc/docs/source_connector.html#features">here</a>. In this case, we will be using the timestamp+increment mode which allows us to capture all updates that result in a unique tuple (id, timestamp).</li>
<li><code>timestamp.column.name</code>: the column name which has the timestamps</li>
<li><code>incrementing.column.name</code>: the column which has incremental IDs</li>
<li><code>topic.prefix</code>: to identify the Kafka topics ingested from PostgreSQL we can specify a prefix value which will be appended to all the table names and the topic name will be prefix+table name</li>
</ul>
<p>The <code>source-postgres.properties</code> should look like this:</p>
<h2>Schema Registry</h2>
<p>The JDBC connector from Confluent uses <a href="http://docs.confluent.io/3.1.2/schema-registry/docs/index.html">Schema Registry</a> to store schema for the messages. A service like schema registry is very useful in tracking and managing scheme updates with proper versioning to make sure downstream processing doesn’t break. Discussing <a href="http://docs.confluent.io/3.1.2/schema-registry/docs/index.html">Schema Registry</a> is outside the scope of this blog, however, I highly encourage reading about it. We can start schema registry as follows:</p>
<p><code>~$ /usr/local/confluent/bin/schema-registry-start /usr/local/confluent/etc/schema-registry/schema-registry.properties &amp;</code></p>
<h2>Ingest data from PostgreSQL tables to Kafka topics</h2>
<p>Let’s create a topic in which we want to consume the updates from PostgreSQL. It is good practice to explicitly create topics so that we can control the number of partitions and replication factor as we may not want to stick with the default values. Our topic name will be <code>postgres_users</code>.</p>
<p><code>~$ /usr/local/kafka/bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 3 --partitions 1 --topic postgres_users</code></p>
<p>You can check that the topic exists using the following command:</p>
<p><code>~$ /usr/local/kafka/bin/kafka-topics.sh --describe --zookeeper localhost:2181 --topic postgres_users</code></p>
<p>We will be using Kafka Connect in stand-alone mode and we can start the stand-alone job to start consuming data from PostgreSQL table as follows:</p>
<p><code>~$ /usr/local/confluent/bin/connect-standalone /usr/local/confluent/etc/schema-registry/connect-avro-standalone.properties /usr/local/confluent/etc/kafka-connect-jdbc/source-postgres.properties</code></p>
<p>The <code>jdbc</code> connector serializes the data using Avro and we can use the Avro console consumer provided by Confluent to consume these messages from Kafka topic. You can run the following command on the Kafka broker that has the Confluent platform and Schema Registry running.</p>
<p><code>~$ sudo /usr/local/confluent/bin/kafka-avro-console-consumer --new-consumer --bootstrap-server localhost:9092 --topic postgres_users --from-beginning</code></p>
<p>If you want to consume this topic from a different broker, setup the Confluent platform on that broker, start Schema Registry and you should be able to use the above command. The messages on the console should look as follows:</p>
<p>You can check that these are all the rows in your PostgreSQL table. Try inserting another row or updating an existing row while having this console consumer running. You’ll see that the updates from PostgreSQL will be captured in this topic.</p>
<h2>Setting up Redshift</h2>
<p>Setup a Redshift instance by following the steps <a href="http://docs.aws.amazon.com/redshift/latest/gsg/rs-gsg-launch-sample-cluster.html">here</a>. Once the Redshift instance is ready, get the endpoint from the Redshift dashboard.</p>
<p>We can use the <code>psql</code> client to connect to Redshift as follows:</p>
<p><code>~$ psql -h kafka-redshift.cniqeoxrupxt.us-west-2.redshift.amazonaws.com -p 5439 &lt;DATABASE&gt; &lt;USERNAME&gt;</code></p>
<p>Replace the Redshift endpoint templates with your actual Redshift endpoint. You will be prompted for the password. Once connected to Redshift, let’s create a table with the same name as the Kafka topic from which we want to write the messages to Redshift. The SQL statement to create the Redshift table is:</p>
<h2>Download the Redshift JDBC driver</h2>
<p>The Confluent JDBC connector doesn’t ship with a Redshift JDBC driver so we need to download it. You can use the following script to download the driver and place it in the path where the connect-standalone process can find it.</p>
<h2>Redshift sink properties file</h2>
<p>We will use the template sink file — <code>/usr/local/confluent/etc/kafka-connect-jdbc/sink-quickstart-sqlite.properties</code> — to create the properties file to use Redshift as a sink. Copy this template file to a file named <code>sink-redshift.properties</code>. Change the following properties:</p>
<ul>
<li><code>name</code>: name for the connector</li>
<li><code>topics</code>: Kafka topic to write data from</li>
<li><code>connection.url</code>: JDBC endpoint for Redshift</li>
<li><code>auto.create</code>: it is <code>true</code> by default and we will change it to <code>false</code> as we’ve already created the table in Redshift that this data should be written to. It is good practice to create the table yourself and control the schema explicitly.</li>
</ul>
<p>The <code>sink-redshift.properties</code> should look as follows:</p>
<h2>Send messages from the Kafka topic to Redshift</h2>
<p>We are all set to have messages from the Kafka topic write to the Redshift table. Connect standalone process can take multiple connectors at a time — they just need to be space separated config files. Stop the previous connect stand-alone job and start a new one, this time specifying config files for both PostgreSQL as a source and Redshift as a sink. You can use the following statement:</p>
<p><code>~$ /usr/local/confluent/bin/connect-standalone /usr/local/confluent/etc/schema-registry/connect-avro-standalone.properties /usr/local/confluent/etc/kafka-connect-jdbc/source-postgres.properties /usr/local/confluent/etc/kafka-connect-jdbc/sink-redshift.properties</code></p>
<p>With this running, connect to your Redshift cluster from any machine using <code>psql</code> and query the <code>postgres_users</code> table. You should see the following rows, though not necessarily in this order.</p>
<p>Keep the Connect job running and insert/update a row in PostgreSQL. You will see this information propagate to the Kafka topic, and from the topic to the Redshift table.</p>
<h2>Conclusion</h2>
<p>In this blog, we saw how we can use different systems as sources and sinks for Kafka. There are a lot of other <a href="https://www.confluent.io/product/connectors/">connectors available</a> making various systems integrable with Kafka making Kafka the go-to choice to transport data in a centralized way throughout the infrastructure.</p>
<p><em>The examples here are only for prototyping purposes and haven’t been tested in any production setup. There are a few things these connectors don’t do yet like throw an exception when the topic specified doesn’t exist, etc. To use these connectors in production, make sure you’ve tested the setup comprehensively.</em></p>
        </body>
    </html>
    