
    <!DOCTYPE html>
    <html>
        <head>
            <meta charset="utf-8">
            <meta name="viewport" content="width=device-width">
            <title>Clearing Programming Interview Assignment RSS Feed 938e974d2de74cafa81c44cb68725b71</title>
            
            
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/open-fonts@1.1.1/fonts/inter.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@exampledev/new.css@1.1.2/new.min.css">
    <link rel="stylesheet" href="https://unpkg.com/github-syntax-dark@latest/lib/github-dark.css"/>
    
        </head>
        <body>
            <header>
                <nav>
                    <a href="https://patricktrainer.github.io/static-site">Home</a> /
                    <a href="https://github.com/patricktrainer">GitHub</a> / 
                </nav>
            </header>
            <h1><a id="user-content-clearing-programming-interview-assignment-rss-feed-parser-in-python" class="anchor" aria-hidden="true" href="#clearing-programming-interview-assignment-rss-feed-parser-in-python"><span aria-hidden="true" class="octicon octicon-link"></span></a>Clearing Programming Interview Assignment: RSS Feed Parser in Python</h1>
<p>Created: May 21, 2020 9:00 AM
Status: Ready to Start
URL: <a href="https://towardsdatascience.com/rss-feed-parser-in-python-553b1857055c" rel="nofollow">https://towardsdatascience.com/rss-feed-parser-in-python-553b1857055c</a></p>
<p><a target="_blank" rel="noopener noreferrer" href="Clearing%20Programming%20Interview%20Assignment%20RSS%20Feed%20938e974d2de74cafa81c44cb68725b71/1S4iy1CDUP1npJcrKIXUb8g.jpeg"><img src="Clearing%20Programming%20Interview%20Assignment%20RSS%20Feed%20938e974d2de74cafa81c44cb68725b71/1S4iy1CDUP1npJcrKIXUb8g.jpeg" alt="1*S4iy1CDUP1npJcrKIXUb8g.jpeg" style="max-width: 100%;"></a></p>
<h1><a id="user-content-problem-elaboration" class="anchor" aria-hidden="true" href="#problem-elaboration"><span aria-hidden="true" class="octicon octicon-link"></span></a><strong>Problem Elaboration</strong></h1>
<p>So instead of diving right into the tech details, I’ll like to go over the problem context.
For those of you who don’t know, RSS is a web-based content (or feed) sharing format. (<a href="https://en.wikipedia.org/wiki/RSS" rel="nofollow">https://en.wikipedia.org/wiki/RSS</a>).
Here are the details of the problem at hand:</p>
<ol>
<li>A suitable data model to represent each posts needs to designed</li>
<li>Any relational database capable of python connectivity could be used to store the post data</li>
<li>Libraries capable of RSS parsing (such as feedparser) is forbidden</li>
<li>The load should be incremental, i.e., only records not processed earlier should get processed</li>
<li>The script should be scheduled to run once a day to get updates</li>
</ol>
<p>Obviously I decided to use <em><strong>python 3.7</strong></em>, with the end of life support coming for <em><strong>python 2.7</strong></em>. <strong>#3</strong> above basically meant I had to implement the RSS parser on my own. All other decisions were pretty straight-forward given the time constraint of 1 day, leaving 3–4 hours for this work (assuming 8–9 hours given to the day job).
Here is what I ended up using:</p>
<blockquote>
<ol>
<li>The restriction of RSS parser libraries, basically expected me to write my own parser. Since it’s ultimately xml-based content, I decided to use the ever-reliable BeautifulSoup Library (<a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/)2" rel="nofollow">https://www.crummy.com/software/BeautifulSoup/bs4/doc/)2</a>. The relational database I chose was postgres (<a href="https://www.postgresql.org/" rel="nofollow">https://www.postgresql.org/</a>). No particular reason, except ease of usage and familiarity and obviously an insanely popular open source support.3. Library apscheduler (<a href="https://apscheduler.readthedocs.io/en/latest/index.html" rel="nofollow">https://apscheduler.readthedocs.io/en/latest/index.html</a>) to schedule task once a day (a simple library to start with, airflow (<a href="https://airflow.apache.org/)/" rel="nofollow">https://airflow.apache.org/)/</a> azkaban (<a href="https://azkaban.github.io/" rel="nofollow">https://azkaban.github.io/</a>) would’ve been an overkill)4. Library psycopg2 (<a href="https://pypi.org/project/psycopg2/" rel="nofollow">https://pypi.org/project/psycopg2/</a>) to support postgres (<a href="https://pypi.org/project/psycopg2/" rel="nofollow">https://pypi.org/project/psycopg2/</a>) (don’t think it needs an explanation, but didn’t want to use wrappers like SQLAlchemy (<a href="https://www.sqlalchemy.org/))5" rel="nofollow">https://www.sqlalchemy.org/))5</a>. Also, since no environment specifications were given, I decided to build all of this using two docker (<a href="https://www.docker.com/" rel="nofollow">https://www.docker.com/</a>) containers, one for python and one for postgres.</li>
</ol>
</blockquote>
<p>With approach shared above, let’s get you started with the implementation!</p>
<h1><a id="user-content-setting-things-up" class="anchor" aria-hidden="true" href="#setting-things-up"><span aria-hidden="true" class="octicon octicon-link"></span></a><strong>Setting things up</strong></h1>
<p>First set up the docker environment and containers:</p>
<ol>
<li>Create a separate network for the containers to interact with:</li>
</ol>
<pre><code>docker network create rss
</code></pre>
<ol start="2">
<li>Create the postgres container with environment variables for DB name, password; expose ports, set bind mounts and working directory:</li>
</ol>
<pre><code>docker run -d --name rss-postgres \
 --net=rss \
 -e POSTGRES_DB=audioboom \
 -e POSTGRES_PASSWORD=parserssfeed \
 -p 5432:5432 \
 -v $(PWD):/home \
 -w /home  \
 postgres
</code></pre>
<ol start="3">
<li>Create the python container, bind mounts, set working directory and run it:</li>
</ol>
<pre><code>docker run -dt --name rss-python \
 --net=rss \
 -v $(PWD)/src:/home/src \
 -w /home/src  \
 conda/miniconda3-centos6 bash
</code></pre>
<ol start="4">
<li>Install the necessary libraries for python:</li>
</ol>
<pre><code>docker exec rss-python conda update -c base -c defaults conda
docker exec rss-python conda install beautifulsoup4 lxml psycopg2
docker exec rss-python conda install -c conda-forge apscheduler
</code></pre>
<p>Let’s start building our data model now…</p>
<p>After reviewing some of the posts, I realised there needs to be three entities:</p>
<blockquote>
<ol>
<li>posts: Keeping entry of each post published on the feed2. itunes_data: A post could optionally contain link to it’s itunes listing3. media: A post could 0 or more media objects present</li>
</ol>
</blockquote>
<p>Keeping track of these three entities pretty much contained the entire post.
Please use this <em><strong><a href="https://github.com/vintageplayer/RSS-Parser/blob/master/create_db.sql">github link</a></strong></em> for the exact create table queries (as they are pretty straightforward)
The tables can be created in one shot by running:</p>
<pre><code>docker exec -it rss-postgres psql -U postgres -d audioboom -f create_db.sql
</code></pre>
<p><strong>Helper modules</strong>Three scripts apart from the main script were created to abstract some of the underlying functionality with function calls:</p>
<blockquote>
<ol>
<li>content_fetcher.py: Use to semi-robustly handle a web-page request and return it’s content2. data_parser.py: Converts the web content to a BeautifulSoup object for parsing and parses a given RSS post record in the feed and returns a dictionary of the same.3. db_connect.py: Contains DB helper functions to fetch a connection, get the count of records already present (for incremental load) and execute a given query.</li>
</ol>
</blockquote>
<p>Finally let’s build the script connecting all the pieces together…<strong>1.</strong> <strong>Imports:</strong> The following lines will import the required modules and objects</p>
<pre><code>from data_parser import get_soup, parse_record, store_tags
from db_connect import get_connection, get_max_records,execute_query
from apscheduler.schedulers.blocking import BlockingScheduler
</code></pre>
<p><strong>2.</strong> We’ll define some global variables also (I know not a recommended practice, but given the time constraint, it was a trade off we all have to take)</p>
<pre><code># Query to find the max record processed so far
get_max_query = 'SELECT COALESCE(max(itunes_episode),0) FROM tasteofindia.posts;'# Query template to insert values in any table
query_string = 'INSERT INTO tasteofindia.{0} ({1}) VALUES ({2}{3});'# List of columns present in the table
col_list  = {
 'posts'  : [&lt;check the github script for the actual names&gt;]
 ,'itunes_data' : [&lt;check the github script for the actual names&gt;]
 ,'media'  : ['itunes_episode','url','type','duration','lang','medium']
}# Creating insert queries for all the tables from template
query_strings = {k: query_string.format(k , ','.join(col_list[k]),('%s,'*(len(col_list[k])-1) ),'%s' ) for k in col_list}
</code></pre>
<blockquote>
<p>The column lists for posts &amp; itunes_data is not shown. Please refer the github link for the same. It’s shown for itunes_episode to get the gist of it.</p>
</blockquote>
<p><strong>3. begin(<em><strong>feed_url</strong></em>,</strong> <em>db_credential_file</em>**)**: Gets the connection of on the credential file and begins parsing the feed from feed url:</p>
<pre><code>def begin(feed_url,db_credential_file):
 try:
  connection = get_connection(db_credential_file)
  update_feed_data(feed_url,connection)
 except Exception as e:
  print('Error Received...')
  print(e)
 finally:
  print('Closing connection')
  connection.close()
</code></pre>
<p>A simple function which starts all the ruckus and gets things moving.<strong>4. update_feed_data(<em><strong>feed</strong></em>,<em><strong>conn</strong></em>):</strong> requests the BeautifulSoup object for the given url and attempts to process any record in it:</p>
<pre><code>def update_feed_data(feed,conn):
 content   = get_soup(feed)
 print(f"Processing Records for : {feed}")
 records   = content.find_all('item')
 process_records(records,conn)
 return
</code></pre>
<p>Again, following the functional paradigm, it does its job by retrieving the BeautifulSoup object and passes the content for further processing.</p>
<p><strong>5. process_records(<em><strong>content</strong></em>,</strong> <em>conn</em>**):** It processes records incrementally and pushes them for persistence (capturing in DB):</p>
<pre><code>def process_records(content,conn):
  record_count = len(content)
  current_max  = get_max_records(conn,get_max_query)
  print('Current Max : ',current_max)
  records = {}  if record_count == current_max:
    print("No new records found!!")
    return records  # List comprehension on the result of map operation on records
  [persist_taste_of_india_record(conn,record) for record in map(parse_record, content[record_count-current_max-1::-1])]
</code></pre>
<p>This is the biggest function. It checks if new records are found. If yes, it first invokes <em><strong>parse_record()</strong></em> for each record, then goes ahead to persist the record.</p>
<p><strong>6. persist_tastse_of_india_record(<em><strong>conn</strong></em>,<em><strong>data</strong></em>):</strong> It tries to persist each component of a post separately (based on the entities defined)</p>
<pre><code>def persist_taste_of_india_record(conn,data):
  persist_record(conn,data,'posts')
  persist_record(conn,data['itunes'],'itunes_data')
  for media in data['media']:
    persist_record(conn,media,'media')
  conn.commit()
 return True
</code></pre>
<p><strong>conn.commit()</strong> is necessary, else the changes in the database aren’t permanent and will be lost once the session expires.</p>
<p><strong>7. persist_record(<em><strong>conn</strong></em>,<em><strong>data</strong></em>,<em><strong>tb_name</strong></em>):</strong> Execute the insert query based on the object type:</p>
<pre><code>def persist_record(conn,data,tb_name):
 query_param  = tuple(
                list(map(lambda k : data[k],col_list[tb_name]))) execute_query(conn,query_strings[tb_name],query_param)
 return
</code></pre>
<p><em><strong>query_param</strong></em> simply stores the values in the column order in a tuple.<em><strong>execute_query()</strong></em> finally inserts the data into the database</p>
<ol start="8">
<li>
<strong>Executing and scheduling it:</strong> The script is completed by invoking the begin function and scheduling it for once everyday execution as follows:</li>
</ol>
<pre><code>if __name__ == '__main__':
  feed_url  = 'https://audioboom.com/channels/4930693.rss'
  db_credentials = 'connection.json'  print('Main Script Running...')
  begin(feed_url,db_credentials)
  scheduler = BlockingScheduler()
  scheduler.add_job(begin, 'interval',[feed_url,db_credentials], hours=24)  try:
    scheduler.start()
  except Exception as e:
    print('Stopping Schedule!!')
</code></pre>
<p>I’m using blocking scheduler here, thus the python thread is always alive. If you ever want to stop the execution, the <strong>try…catch</strong> block is to exit cleanly. Now you simply need to execute the main script using the following command to run it once immediately, as well as schedule it for once every day at the same time:</p>
<pre><code>docker exec -d rss-python python main.py
</code></pre>
<p>That’s it. You have an RSS-parser ready, running every day and updating the DB.</p>
<p>Obviously, a lot of upgrade and enhancements are possible. Many best practices aren’t followed. SOLID principles, background scheduler, using docker compose files, etc are something to probably start with first. While building this out, I had focused on getting a functional system out first and minimal effort spent in re-factoring and designing.
Nonetheless, please do leave your comments and feel free to reach out to me here/through github.</p>

        </body>
    </html>
    